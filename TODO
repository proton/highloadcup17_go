Tip 2: Pooling the buffer

sync.Pool is your best friend.

Profile your program in production. go tool pprof --alloc_objects your-program mem.pprof usually gives better insights for optimization opportunities than go tool pprof your-program cpu.pprof.

Можно еще действительно перейти с map на array, как хотел
array вместо map 1_000_002 - visits
cap(array)

Golang 1.9: A new type in the sync package serves as a concurrent map with amortized-constant-time loads, stores, and deletes. Thus, multiple go routines can call a map's methods concurrently.

Тут простой вариант описан https://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs По ссылкам проект слегка переехал, но все работает

Свой сериалайзер? Позволит пол хранить как bool, строки как []byte

Tip 2: Pooling the buffer

On servers where you have a lot of concurrent encoding going on, you can hand back the byte buffer you get from json.Marshal once you are done using it. An example could look like this:

import "github.com/pquerna/ffjson/ffjson"

func Encode(item interface{}, out io.Writer) {
	// Encode
	buf, err := ffjson.Marshal(&item)
	
	// Write the buffer
	_,_ = out.Write(buf)
	
	// We are now no longer need the buffer so we pool it. 
	ffjson.Pool(buf)
}